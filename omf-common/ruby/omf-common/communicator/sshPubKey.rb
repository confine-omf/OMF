#
# Copyright (c) 2010 National ICT Australia (NICTA), Australia
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
# = sshPubKey.rb
#
# == Description
#
# This file provides a converter that accepts an SSH public key string
# and converts it to an OpenSSL::PKey::RSA object for use in verifying
# received messages.  (DSA support pending).
#
# This file also monkey-patches OpenSSL::PKey to add
# 'from_pubkey_file' and 'from_pubkey_string' methods for conveniently
# creating new key objects.
#

require 'base64'
require 'openssl'

module SSHPubKeyConvert

  #
  # Unpack a 4-byte unsigned integer from the +bytes+ array.
  #
  # Returns a pair (+u32+, +bytes+), where +u32+ is the extracted
  # unsigned integer, and +bytes+ is the remainder of the original
  # +bytes+ array that follows +u32+.
  #
  def SSHPubKeyConvert.unpack_u32(bytes)
    return bytes.unpack("N")[0], bytes[4..-1]
  end

  #
  # Unpack a string from the +bytes+ array.  Exactly +len+ bytes will
  # be extracted.
  #
  # Returns a pair (+string+, +bytes+), where +string+ is the
  # extracted string (of length +len+), and +bytes+ is the remainder
  # of the original +bytes+ array that follows +string+.
  #
  def SSHPubKeyConvert.unpack_string(bytes, len)
    return bytes.unpack("A#{len}")[0], bytes[len..-1]
  end

  #
  # Convert a string in SSH public key format to a key object
  # suitable for use with OpenSSL.  If the key is an RSA key then an
  # OpenSSL::PKey::RSA object is returned.  If the key is a DSA key
  # then an OpenSSL::PKey::DSA object is returned.  In either case,
  # the object returned is suitable for encrypting data or verifying
  # signatures, but cannot be used for decrypting or signing.
  #
  # The +keystring+ should be a single line, as per an SSH public key
  # file as generated by +ssh-keygen+, or a line from an SSH
  # +authorized_keys+ file.
  #
  def SSHPubKeyConvert.convert(keystring)
    (type, b64, id) = keystring.split(' ')
    decoded_key = Base64.decode64(b64)
    (n, bytes) = unpack_u32(decoded_key)
    (keytype, bytes) = unpack_string(bytes, n)

    if keytype == "ssh-rsa" then
      (n, bytes) = unpack_u32(bytes)
      (estr, bytes) = unpack_string(bytes, n)
      (n, bytes) = unpack_u32(bytes)
      (nstr, bytes) = unpack_string(bytes, n)

      key = OpenSSL::PKey::RSA.new
      key.n = OpenSSL::BN.new(nstr, 2)
      key.e = OpenSSL::BN.new(estr, 2)
      key
    elsif keytype == 'ssh-dss' then
      (n, bytes) = unpack_u32(bytes)
      (pstr, bytes) = unpack_string(bytes, n)
      (n, bytes) = unpack_u32(bytes)
      (qstr, bytes) = unpack_string(bytes, n)
      (n, bytes) = unpack_u32(bytes)
      (gstr, bytes) = unpack_string(bytes, n)
      (n, bytes) = unpack_u32(bytes)
      (pkstr, bytes) = unpack_string(bytes, n)

      key = OpenSSL::PKey::DSA.new
      key.p = OpenSSL::BN.new(pstr, 2)
      key.q = OpenSSL::BN.new(qstr, 2)
      key.g = OpenSSL::BN.new(gstr, 2)
      key.pub_key = OpenSSL::BN.new(pkstr, 2)
      key
    else
      raise "Unknown key type '#{keytype}'"
    end
  end

  #
  #  Generate test keys in the "test-keys" subdirectory.  Calls out to +ssh-keygen+.
  #
  def gen_keys(force = false)
    require 'fileutils'
    include FileUtils
    should_generate = false
    if not force then
      if not (File.directory?("test-keys") and File.exists?("test-keys/rsa")) then
        should_generate = true
      end
    else
      should_generate = true
    end

    if should_generate then
      puts "Generating public RSA keypair"

      mkdir("test-keys") unless File.exists?("test-keys")
      rm("test-keys/rsa") if File.exists?("test-keys/rsa")
      system("ssh-keygen -P '' -t rsa -f test-keys/rsa")
    end
  end

  #
  # Run some simple checks to verify that the RSA key conversion works
  # properly for verifying signatures.
  #
  def check_sign_verify_rsa
    text = "Hello World"

    privkey = OpenSSL::PKey::RSA.new(File.read("test-keys/rsa"))

    signature = privkey.sign(OpenSSL::Digest::SHA1.new, text)
    pubkey = SSHPubKeyConvert.convert(File.read("test-keys/rsa.pub"))
    system("/bin/echo -n \"#{text}\" | openssl dgst -sha1 -sign test-keys/rsa > test-keys/rsa.text.sig")
    cmdline_signature = File.read("test-keys/rsa.text.sig")

    v1 = privkey.public_key.verify(OpenSSL::Digest::SHA1.new, signature, text)
    v2 = pubkey.verify(OpenSSL::Digest::SHA1.new, signature, text)
    v3 = pubkey.verify(OpenSSL::Digest::SHA1.new, cmdline_signature, text)

    puts "Verifying privkey->pubkey    #{v1}"
    puts "Verifying privkey->sshpubkey #{v2}"
    puts "Verifying cmdline->sshpubkey #{v3}"
  end

  #
  # Run tests.
  #
  def run
    gen_keys
    check_sign_verify_rsa
  end
end

OpenSSL::PKey.class_eval do
  #
  # Create a new OpenSSL::PKey from file +string+.  Tries to intepret
  # +string+ as an SSH pubic key string, and attempts to convert it to
  # a PKey object (either PKey::RSA or PKey::DSA).
  #
  def self.from_pubkey_string(string)
    SSHPubKeyConvert.convert(string)
  end

  #
  # Create a new OpenSSL::PKey from file +filename+.  Opens the file
  # with the given name and takes the first line of the file as an SSH
  # pubic key string, and attempts to convert it to a PKey object
  # (either PKey::RSA or PKey::DSA).
  #
  def self.from_pubkey_file(filename)
    key_text = File.read(filename)
    key_text = key_text.split('\n')[0]
    self.from_pubkey_string(key_text)
  end
end

if __FILE__ == $PROGRAM_NAME then
  include SSHPubKeyConvert
  run
end
